> 💡 **한 줄 요약**
>
> JVM의 힙에서 더 이상 참조되지 않는 객체를 찾아 메모리에서 제거 후 재배열한다.

### 1. 🤔 왜 사용하는가

- JVM의 핵심 기능 중 하나
- 사용되지 않는 메모리를 자동으로 회수하는 메커니즘
- 더 이상 참조되지 않는 객체를 찾아 메모리를 해제
  → 메모리 누수 방지, 효율적인 메모리 사용 도모

### 2. 💡 무엇인지 아는가(특징)

- **OutofMemoryErrors**

  - 프로그램이나 애플리케이션이 사용 가능한 양보다 많은 메모리를 할당하려고 할 때 발생하는 오류
  - 앱 실행하는 동안 JVM이나 다른 플랫폼에서 `메모리 부족` 시 발생

- **작동 원리**

  - Java에서 모든 객체는 동적 할당 위해 예약된 메모리의 일부인 힙에 저장
  - 객체가 더 이상 참조되지 않으면 가비지 컬렉션 대상이 됨
  - 가비지 컬렉터는 주기적으로 힙 메모리를 스캔해 사용되지 않는 객체 찾음

  - **가비지 컬렉션 과정**
    1. 마킹 (Markong) : 더 이상 사용되지 않는 객체 식별
       - 프로그램에서 아직 참조하고 있는 모든 객체 표시
       - 전역 변수, 로컬 변수 및 메서드 매개변수와 같은 루트 객체 집합 ~ 해당 루트에서 연결할 수 있는 모든 객체 추적해 작업
       - 루트에서 접근할 수 없는 객체는 가비지 컬렉션 대상
    2. 삭제 (Deletion) : 식별된 객체를 메모리에서 제거
       - 실제로 메모리 해제, 사용 가능한 메모리 공간 증가
       - Java 힙 청소, 참조되지 않는 객체에서 사용하는 메모리 식별 및 회수
       - 참조되지 않는 객체에서 사용하는 메모리를 할당 해데
       - 이 메모리를 사용 가능한 메모리 풀에 다시 추가
    3. 정리 (Compaction) : 메모리 내 객체들을 재배치해 메모리 단편화 줄임
       - 후속 메모리 할당 요청을 더 효율적으로 처리하기 위함
       - 나머지 객체에서 사용하는 메모리 재배열해 조각화를 최소화
       - 객체를 서로 더 가깝게 이동, 더 큰 연속 메모리 블록 만듦

- **최적화 전략**

  1. 적절한 가비지 컬렉터 선택
     - JVM은 여러 가비지 컬렉터 제공 → 각 특성과 성능 다름
  2. 객체의 생명 주기 최적화
     - 가비지 컬렉션의 부담 줄임
     - 잦은 객체 생성과 소멸은 가비지 컬렉션의 빈번한 실행 유발할 수 있음
  3. 가비지 컬렉션 로그를 분석하여 성능 저하 원인 파악, JVM 옵션 조정
     - 로그 분석 통해 애플리케이션의 메모리 사용 패턴 이해 및 최적화 전략 수립 가능

- **가비지 컬렉터 유형**
  - 전체 가비지 컬렉션 : 모든 메모리 검색하고 사용하지 않는 객체 컴파일 및 제거
  - 증분 가비지 컬렉션 : 사용하지 않는 메모리 자동 회수해 할당 해제

### 3. ✅ 장점

- 메모리 관리 부담 줄임
- 메모리 누수 방지
- 동적 메모리 할당 : 필요에 따라 런타임에 메모리 할당 가
- 성능 향상
- 메모리 최적화

### 4. ⚠️ 단점

- **컬렉션 과정에서 발생하는 Stop-The-World (STW) 현상**
  - 가비지 컬렉션 수행하는 동안 JVM이 애플리케이션 실행 멈추고 GC 작업에 집중
  → 애플리케이션의 성능 저하 일으킬 수 있음
