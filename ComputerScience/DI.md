> 💡 **한 줄 요약**
>
> 어떤 객체가 필요로 하는 객체를 직접 만들지 않고 외부에서 주입하는 방식이다.
>
> 이를 통해 객체 간 결합도가 감소할 수 있고, 테스트 용이, 코드의 재사용성이 향상된다.

### 1. 🤔 왜 사용하는가

- 스프링 컨테이너가 스프링 빈의 의존성을 자동으로 주입하는 과정

- A 객체가 어떤 작업을 수행하기 위해 B 객체를 필요로 하는 경우에 두 객체 사이에 의존성이 존재한다고 함
- 이때, A객체가 아닌 외부의 C 객체가 B를 생성한 뒤에 이를 전달해 의존성을 해결하는 방법

- 객체 지향 프로그래밍에서 중요한 디자인 패턴 중 하나
  - 클래스가 다른 클래스에 의존하는 상황 해결위해 사용
    (클래스 A가 클래스 B를 내부에서 생성하고 사용하는 경우, A는 B에 의존함)
- 객체가 필요로 하는 의존 객체를 외부에서 제공(주입)하는 방식

  (클래스A의 생성자에서 클래스 B를 파라미터로 받아들이는 방식으로 의존성 주입

  ⇒ 클래스 A는 B를 직접 생성하지 않아도 외부에서 주입된 B 사용 가능)

- 메인 모듈이 직접 다른 하위 모듈에 대한 의존성을 주기보다는 중간에 의존성 주입자 (dependency injector)가 이 부분을 가로채 메인 모듈이 간접적으로 의존성을 주입하는 방식
- 메인 모듈과 하위 모듈 간의 의존성을 조금 더 느슨하게 만들 수 있으며 모듈을 쉽게 교체 가능한 구조로 만듦

### 2. 💡 무엇인지 아는가(특징)

- **원리**

  - 객체는 자신이 사용할 의존 객체 직접 생성 X → 외부에서 생성된 객체를 주입받음
    ⇒ 객체는 자신의 구현에만 집중 가능, 변경에 유연하게 대처 가능

- **주입 방식**

  1. **생성자 주입(constructor injection)**
     - 동일한 의존이 필요한 경우 사용
     - 객체 생성 시점에 의존성을 주입
  2. **수정자 주입(setter injection)**
     - 동일한 의존이 필요한 경우 사용
     - setter 주입만을 사용할 경우, 객체가 일시적으로 불완전한 상태일 수 있음
       - 생성자 주입과 함꼐 사용하는 것이 좋은 방법
     - 객체 생성 후 세터 메서드를 통해 의존성 주입
  3. **메서드 주입(method injection)**
     - 실행할 때마다 의존 대상이 매번 달라지는 것처럼 일시적인 의존이 필요한 경우 사용
     - 의존성 주입을 위한 별도 인터페이스 사용

- @Autowired : 의존성 주입 어노테이션
  - 타입과 이름이 같은 빈을 탐색해 주입

### 3. ✅ 장점

- **객체 간 결합도 낮춤**
  - 코드의 변경이 필요한 경우 최소한의 수정만으로 원하는 기능 구현 가능
  - 클래스가 직접 다른 클래스에 의존하지 않고, 외부에서 주입된 객체 사용
- **코드의 재사용성 높임**
  - 모듈화를 통해 유지보수 용이
- **테스트 용이성 개선**
  - 테스트 시, 실제 객체 대신 모의 객체(Mock Object)를 주입하여 테스트 가능해 테스트 환경 쉽게 구성 가능
- **유연하고 재사용할 수 있는 설계 생성**
  - A 객체 내부에 B를 직접 생성
    → 결합도 높아짐
  - B에 대한 생성 책임을 C에게 위임,
    C가 A에게 다시 전달해 주는 방식(의존성 주입)
        → A는 B에 대한 결합도 낮춤
