> 💡 **한 줄 요약**
>
> Streaming SSR은 서버에서 렌더링된 HTML을 한 번에 완성해서 보내는 방식이 아니라, 준비된 부분부터 점진적으로 스트리밍해서 클라이언트로 전달하는 기술로, 사용자는 페이지의 중요한 콘텐츠를 빠르게 확인할 수 있어 사용자 경험을 개선할 수 있다.

### 1. 🤔 왜 사용하는가

- **Streaming SSR**
  - 서버에서 렌더링된 HTML을 한 번에 완성해서 보내는 방식이 아니라, 준비된 부분부터 점진적으로 스트리밍해서 클라이언트에 전달하는 기술
  - 사용자는 페이지의 중요한 콘텐츠 빠르게 확인 가능

### 2. 💡 무엇인지 아는가(특징)

- **기존 SSR**

  - 서버에서 모든 데이터를 처리한 뒤, 완전한 HTML을 전송

- **Streaming SSR**
  - 서버가 데이터를 준비하는 즉시 HTML 조각을 스트림 형태로 보냄
    - 클라이언트는 이를 실시간으로 렌더링
  - React 18에서 `renderToPipeableStream API` 통해 구현 가능
    - 서버에서 HTML을 조각 단위로 스트리밍 할 수 있도록 지원
  ```jsx
  renderToPipeableStream(<App />, {
    onShellReady() {
      res.setHeader("Content-Type", "text/html");
      stream.pipe(res);
    },
  });
  ```

### 3. ✅ 장점

- **초기 로딩 시간 단축**
  - HTML의 일부라도 준비되는 즉시 클라이언트가 렌더링을 시작
  - TTFB(Time to First Byte) 개선
  - 데이터 많거나 복잡한 대규모 애플리케이션에서 효과적
  - 사용자가 중요한 콘텐츠를 먼저 확인할 수 있어 전반적인 사용자 경험 향상

⇒ 기존 SSR의 한계 극복, 더욱 빠르고 효율적인 웹 페이지 렌더링 가능

### 4. ⚠️ 고려사항

- 클라이언트에서 부분적으로 전송된 HTML을 제대로 Hydration할 수 있도록 설계 필요
- SEO나 캐싱 정책과 호환성 고려 필요

> **스트리밍된 데이터와 리액트의 Hydration 과정에서 발생 가능한 문제**

- **렌더링되는 HTML과 리액트의 상태 불일치**
  - 스트리밍된 HTML이 서버에서 먼저 클라이언트로 전송
  - 리액트가 실행되기 전까지 그냥 정적인 상태로만 보여짐
  - 이후 Hydration 과정에서 이 HTML에 리액트의 상태와 이벤트 핸들러 결합됨
  - 이때, 서버와 클라이언트 사이 데이터 맞지 않을 시 문제 발생
- 예시
  - 서버에서 렌더링된 데이터가 클라이언트에서 Hydration 시점에 변경되어 있다면
  - 리액트가 경고 띄우거나, 예상치 못한 UI 동작 나타날 수 있음
  - 비동기 처리를 Suspense로 할 경우, 데이터가 늦게 로드되어 UI가 달라질 수 있음

### 5. 🔄 개선 방법

> **불일치 문제 해결**

- **서버와 클라이언트에서 동일한 데이터 소스 사용**
  - Tanstack Query 같은 라이브러리 활용 시 데이터 동기화하기 수월
  - Suspense와 fallback 활용 시, 데이터가 아직 준비되지 않았을 때, 안정적인 화면 보여줄 수 있음
  - 사용자 입장에서 데이터 로드되기 전, UI가 흔들리는 문제 줄일 수 있음
