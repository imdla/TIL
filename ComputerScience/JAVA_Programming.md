### 1. 🤔 왜 사용하는가

- **자바 프로그램이 실행되는 흐름**
  1. `.java` 파일은 JDK에 포함된 javac(java complier)를 통해 컴파일
     - JVM이 이해할 수 있는 바이트 코드로 변환
       → `.class` 파일이 생성
       → 이후 JVM이 담당
  2. 클래스 로더(Class Loader)가 바이트 코드를 JVM 메모리에 동적으로 로드
     - 로드된 바이트 코드는 Method Area에 저장
     - 로딩(Loading), 링킹(Linking), 초기화(Initialization) 단계 거침
  3. 실행 엔진(Execution Engine)이 로드된 바이트 코드를 실행
     - 바이트 코드는 컴퓨터가 읽을 수 없어 인터프리터(Interpreter)와 JIT(Just-In-Time Complier)를 함께 사용해 기계어로 변환
     - 인터프리터 : 바이트 코드를 한 줄씩 읽어 실행하는 방식
     - JIT 컴파일러 : 자주 실행되는 메서드(Hotspot)를 감지하면 해당 메서드 전체를 네이티브 코드로 변환해 캐싱

### 2. 💡 무엇인지 아는가(특징)

> **클래스 로더가 바이트 코드를 동적으로 로드 ?**

- 프로그램이 시작될 때 모든 클래스를 한꺼번에 로드하는 것 아님 ❎
- 런타임 시점에 필요한 클래스만 로드하는 것 ✅

- 클래스 로드 사용

  - 인스턴스를 생성할 때
  - static 메서드나 변수를 사용할 때
  - static 변수에 값을 할당할 때

- **동적 로드 방식 장점**
  - 불필요한 클래스 로드 방지
    → 메모리 효율적 사용

> **로딩, 링킹, 초기화 단계**

- **로딩(Loading)**
  - 클래스 로더가 `.class` 파일을 읽어 JVM 메모리에 로드하는 단계
  - 로드된 클래스는 Method Area에 저장
- **링킹(Linking)**
  - 로드된 클래스가 실행될 수 있도록 준비하는 단계
  - 세 가지의 과정으로 이루어짐
    1. **Verification** : `.class` 파일이 구조적으로 올바른지 확인
    2. **Preparation** : static 변수를 메모리에 할당하고 기본값으로 초기화
    3. **Resolution** : 런타임 상수 풀에 있는 심볼릭 레퍼런스를 실제 메모리 레퍼런스로 교체
- **초기화(Initialization)**
  - static 변수를 사용자가 지정한 값으로 초기화하고 static 블록을 실행하는 단계

> **실행 엔진이 바이트 코드를 기계어로 변환할 때 인터프리터와 JIT 컴파일러를 함께 사용하는 이유**

- 인터프리터 : 바이트 코드를 한 줄씩 읽어 실행하는 방식
  - 장점 : 초기 실행 속도 빠름
  - 단점 : 같은 코드가 반복적으로 실행될 경우 매번 해석 필요 → 성능 저하
- JIT 컴파일러

  - 자주 실행되는 메서드를 네이티브 코드로 변환해 캐싱
  - 장점 : 변환된 코드는 반복 실핼 시 인터프리터보다 훨씬 빠르게 실행
  - 단점 : JIT 컴파일 과정 자체에 시간이 소요 → 초기 실행 시 오버헤드 발생

- 초기 JVM 인터프리터만 사용 → 단점 보완 위해 JIT 컴파일러 도입

⇒ JVM은 두 방식을 함께 사용해 초기 실행 속도 + 높은 반복 실행 성능 동시 달성
