> 💡 **한 줄 요약**
>
> 1. 웹 브라우저에 **URL 입력 후** Enter 키 입력
> 2. 웹 브라우저가 도메인명의 **IP 조회**
>    (먼저 캐시 찾고, 그 다음 DNS 검색) - DNS 조회
> 3. 웹 브라우저가 찾은 IP 주소 기반 서버와의 **TCP 연결 시작**
>    - 서버와 연결 시 로드 밸런싱 사용
> 4. 웹 브라우저가 **HTTP 요청을 서버로 전송**
>    (필요에 따라 HTTPS 보안 통신 진행)
>    - HTTP 요청 : 요청 라인, 헤더, 바디로 구성
> 5. 웹 서버가 요청을 처리하고 **응답을 다시 웹 브라우저로 전송**
> 6. 웹 브라우저가 전송 받은 콘텐츠 렌더링

![image.png](/ComputerScience/assets/browser.png)

## 🤔 알아보기

---

> ▶️ **단계**
>
> 1. 웹 사이트를 호스팅하는 웹 서버의 위치 조회 (DNS 조회)
> 2. 웹 서버에 연결 (TCP 연결 수립)
> 3. 특정 페이지를 가져오기 위한 요청 전송 (HTTP 요청)
> 4. 웹 서버의 응답을 처리 (서버의 응답)
> 5. 사용자가 웹 사이트와 상호 작용할 수 있도록 페이지를 렌더링하는 방법
>    (브라우저 렌더링 파이프라인)

### 1. 웹 브라우저에 URL 입력 후 Enter 키 입력

> https://www.google.com/

- **통신 규약 (Protocol)**
  - `https://` 은 통신 프로토콜
  - 브라우저에 전송 계층 보안(TLS)을 사용해 서버에 연결하도록 지시
    - TLS : 인터넷을 통한 통신을 보호하는 암호화 프로토콜
- **도메인 (Domain)**
  - `www.google.com` 은 웹 사이트의 도메인 이름
  - 특정 서버의 IP 주소를 가리킴
- **경로 (Path)**
  - URL에 리소스에 대한 추가 경로

### 2. 웹 브라우저가 도메인명의 \*\*IP 조회

(먼저 캐시 찾고, 그 다음 DNS 검색)\*\*

> **DNS 조회**
>
> - **브라우저는 도메인 이름을 → IP 주소로 변환 (DNS 조회)**

1. **브라우저는 캐시된 DNS 기록 먼저 확인**
   - DNS 데이터는 웹 브라우저 사이 서로 다른 계층과 인터넷의 다양한 위치에 임시로 저장됨
     → 캐시 (Cache)
   - 고유 캐시, 운영 체제 캐시, 라우터의 로컬 네트워크 캐시, 회사 네트워크 또는 인터넷 서비스 제공업체(ISP)
   - 직접 사용자가 설정한 호스트 파일에 있는 정보가 있는지 먼저 읽어옴
2. **없으면 로컬 DNS 서버에 요청해 해당하는 IP 주소 얻음**
   - 회사 네트워크/ISP의 DNS 서버가 재귀적 DNS 서버 조회 수행
   - 재귀적 DNS 서버 조회
     - 인터넷에 있는 여러 DNS 서버 요청
     - 검색될 때까지 DNS 레코드에 대해 더 많은 DNS 서버에 요청
3. 브라우저에 URL 입력하고 Enter 키 누른 후 브라우저는 **인터넷에서 연결할 서버 파악**
4. **입력한 도메인을 사용해 웹 사이트를 호스팅하는 서버의 IP 주소 조회**

- 특정 웹 브라우저는 사용자가 링크 따라가기 전 도메인 네임 확인하는 DNS Prefetch라는 기능 가지고 있을 수 있음
  - 웹 페이지 내 미리 도메인명 확인할 경우, 사용자가 해당 도메인으로 이동할 때 DNS 확인 시간으로 인한 지연이 발생하지 않음

### 3. 웹 브라우저가 찾은 IP 주소 기반 서버와 **TCP 연결**

> **TCP 연결 수립**
>
> - IP 주소 확인 시 브라우저는 서버와 TCP 연결 수립
> - TCP(Transmission Control Protocol) : 데이터를 신뢰성 있게 전달하기 위한 프로토콜

- **이 과정에서 브라우저는 서버와 3-way handshake 수행**

  - 브라우저가 SYN 패킷 전송
  - 서버가 SYN-ACK 패킷 보냄
  - 다시 브라우저가 ACK 패킷을 보냄

- 인터넷에 연결된 웹 브라우저 요청 패킷 이동
  - TCP/IP(전송 제어 프로토콜) 사용
  - 라우터 장비, 인터넷 서비스 제공회사 교환기를 통해 이동
  - 통신 회사간 경로인 라우팅 테이블을 따라 연결할 IP 주소가 있는 웹 서버 찾음
- 웹 서버에 직접 도달 방법 → 비효율적일 수 있음
  - 웹 사이트들이 직접 서버에 연결하기보다 콘텐츠 전송 네트워크(CDN) 사용해 정적 및 동적 콘텐츠를 웹 브라우저 가까이에 위치 시킴
  - CDN은 콘텐츠를 사용자에게 더 가까이 제공해 사이트의 원본 연결 성능을 개선하는 캐싱 서버의 글로벌 분산 네트워크
- 웹 브라우저 요청은 인터넷 라우팅 테이블에 따라 경로를 순서대로 이동
  - 각 요청은 가장 성능 좋은 위치를 통해 지능적으로 라우팅 되어 브라우저에 콘텐츠를 전송
    → 웹 서버는 로드 밸런싱 기능을 이용
    (로드 밸런서 : 여러 웹 서버의 부하 분산을 해주는 기능)
- 웹 브라우저가 인터넷에서 서버 찾으면 웹 서버와 TCP 연결을 설정, HTTP 통해 평문 통신 시작
  - HTTPS 사용하는 경우, 주고 받는 데이터의 암호화를 위한 TLS 핸드셰이크라는 추가 과정 수행
  - TLS 핸드셰이크 : 암호화할 상호 대상 확인하는 것

### 4. 웹 브라우저가 \*\*HTTP 요청을 서버로 전송

(필요에 따라 HTTPS 보안 통신 진행)\*\*

> **HTTP 요청**

- 웹 브라우저가 페이지의 콘텐츠 요청 위해 서버에 HTTP 또는 HTTPS 요청 전송

  - 형식 : `GET/HTTP/1.1` → 웹 페이지를 요청하는 메시지

- **HTTP 요청**

  - 요청 라인
    - 요청 메서드 : `GET`, `POST`, `PUT`, `PATCH`, `DELETE`
    - 요청된 리소스 가리키는 경로
    - 통신할 HTTP 버전
  - Header (요청에 대한 메타데이터)
    - 요청을 라우팅하는데 도움이 되는 추가 정보를 클라이언트에 전달
    - 어떤 유형의 클라이언트가 요청을 수행하는지 나타냄
  - Body
    - 리소스를 조작하는 요청의 경우(`POST`, `PUT`, `PATCH`) 본문에는 생성하거나 업데이트할 클라이언트의 데이터 포함됨
    - 서버는 요청 헤더인 `Content-Type` 을 기반으로 형식 이해

- **HTTPS 사용 시, 이전에 SSL/TLS 핸드셰이크도 수행**
  - 이 과정에서 브라우저와 서버가 암호화된 연결을 설정 위해
    보안 인증서 교환, 암호화 키 협상

### **5.** 웹 서버가 요청을 처리하고 **응답을 다시 웹 브라우저로 전송**

> **서버의 응답**

1. 웹 서버는 요청을 받고 요청 라인, 헤더 및 본문의 정보를 기반으로 요청 처리 방법을 결정
2. 요청에 대해 서버는 이 경로의 콘텐츠 가져오고 응답 생성해 클라이언트로 다시 전송
   - 서버는 해당 리소스(HTML, CSS, JS 등)를 브라우저에게 응답으로 보냄
   - 응답은 HTTP 응답 상태 코드(status code)와 함께 전달됨
   - **응답**
     - 상태 라인 : 클라이언트에게 요청 상태 알려줌
     - 응답 헤더 : 브라우저에 응답 처리 알려줌
     - 해당 경로에서 요청된 리소스
       - 웹 서버가 동적 리소스를 생성해 코드 조각이나 템플릿에서 HTML 구축하고 동적 데이터와 결합해 응답으로 다시 전송해 웹 브라우저가 페이지를 렌더링함

### **6.** 웹 브라우저가 전송 받은 콘텐츠 렌더링

> **리소스 바탕의 브라우저 렌더링 파이프라인 진행**

1. 웹 브라우저가 서버로부터 응답 받으면 응답 헤더 검사해 리소스 렌더링하는 방법에 대한 정보 확인
   - `Content-Type` 헤더는 브라우저에 응답 본문에서 HTML 리소스를 수신 여부를 알림
2. DOM과 CSSOM 생성 후 렌더 트리 구성한 후, 레이아웃과 페인트 단계를 통해 웹 페이지가 화면에 표시

- `GET` 요청일 경우, 페이지의 구조인 HTML 반환
  - 그러나, 웹 브라우저의 개발 도구로 HTML 검사 시 JS, CSS, 이미지 리소스를 참조하고 웹 페이지를 설계된대로 렌더링하기 위해 추가 데이터를 요청함
- HTML은 CSS나 JS 파일 리소스를 참조
  - 웹 브라우저는 페이지에 스타일을 지정하기 위해 이 CSS 리소스를 가져오도록 서버에 후속 요청함
  - CSS 리소스 요청에 대한 `Content-Type` 헤더는 브라우저에 CSS를 렌더링하도록 지시함
  - 웹 브라우저가 이미지 리소스 요청 시 `Content-Type` 헤더가 브라우저에 텍스트 아닌 데이터임을 알려주고 그에 따라 렌더링하도록 지시
