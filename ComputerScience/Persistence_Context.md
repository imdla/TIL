> 💡 **한 줄 요약**
>
> 영속성 컨텍스는 엔티티를 영구 저장하는 환경으로, 특징으로 1차 캐시, 쓰기 지연, 변경 감지가 있다. 이를 통해 효율적인 영속 로직의 효율성을 높일 수 있다.
>
> 1차 캐싱은 데이터베이스로 읽어온 엔티티를 메모리에 캐싱에 같은 트랜잭션 내 데이터베이스 접근 없이 데이터 재사용이 가능한 것이다.
>
> 쓰기 지연은 여러 변경 사항을 모아 한 번에 데이터베이스에 반영해 네트워크 비용을 줄이고 성능을 향상 시킬 수 있다.
>
> 변경 감지는 엔티티의 변경 사항을 자동으로 감지해 업데이트 쿼리를 생성해 개발자가 수동으로 변경 사항을 관리할 필요 없게 한다.

### 1. 🤔 왜 사용하는가

- 엔티티를 영구 저장하는 환경
- 애플리케이션과 데이터베이스 사이에서 중간 계층 역할
- 트랜잭션 단위로 생성 및 관리

### 2. 💡 무엇인지 아는가(특징)

1. **1차 캐시**
    - 영속 상태의 엔티티는 모두 1차 캐시에 저장
    - 조회 시 먼저 1차 캐시에서 찾고, 없으면 DB에서 조회
    
    ⇒ 데이터베이스로부터 읽어온 엔티티를 메모리에 캐싱해 같은 트랜잭션 내에서 데이터베이스 접근 없이 데이터 재사용 가능
    
2. **동일성 보장**
    - 같은 엔티티 조회 시 항상 같은 인스턴스 반환
3. **트랜잭션을 지원하는 쓰기 지연**
    - 트랜잭션 커밋 전까지 SQL 보내지 않고 모아둠
    - 커밋하는 순간 모아둔 SQL을 DB에 보냄
    - 쿼리를 DB로 즉시 보내지 않고 변경 내용을 1차 캐시에 반영한 후 저장소에 쌓아두러 한 번에 DB로 전송하는 방식
    
    ⇒ 여러 변경 사항을 모아 한 번에 데이터베이스에 반영해 네트워크 비용 줄이고 성능 향상
    
4. **변경 감지 (Dirty Checking)**
    - 엔티티의 변경사항을 자동으로 감지
    - 트랜잭션 커밋 시점에 변경된 엔티티 찾아 UPDATE SQL을 생성
    - 더티 : 데이터베이스에서 원본의 상태가 수정된 것
    - 엔티티가 영속성 컨텍스트에 들어올 때 복사본을 만들고, flush 전 스냅샷과 현재 상태를 비교해 변경 사항 감지 후 저장소에 추가하는 과정
    
    ⇒ 엔티티의 변경 사항을 자동으로 감지해 업데이트 쿼리 생성해 개발자가 수동으로 변경 사항을 관리할 필요 없게 함
    
    - flush : 영속성 컨텍스트의 변경 사항을 데이터베이스에 반영하는 과정
5. **지연 로딩**
    - 연관된 엔티티를 실제 사용하는 시점에 로딩

### 3. ✅ 장점

- 데이터베이스의 연산 성능 향상
- 쉬운 데이터 관리
- 객체 생명주기 관리로 데이터 일관성 유지
- 데이터베이스의 접근을 최소화
