> 💡 **한 줄 요약**
>
> 시간 복잡도는 특정 입력을 기준으로 개략적인 연산의 수를 계산하고, 공간 복잡도는 특정 입력을 기준으로 알고리즘이 얼마나 많은 공간을 차지하는지를 다룬다.

### 1. 🤔 왜 사용하는가

- 문제 해결 → 여러 알고리즘 존재

  - 개발자 : 성능 평가해 최적의 선택 필요
    - 코드 실행해 정확한 시간 측정해 속도 비교
    - 실행 시간 → 기계에 의존적, 비교가 어려울 수 있음
      ⇒ 직접 속도를 측정하지 않고 컴퓨터가 처리해야 하는 연산의 수를 세자

- **시간 복잡도(Time Complexity)**

  - 특정 입력을 기준으로 개략적인 연산의 수를 계산
  - 평가 척도 : 개략적인 연산의 수를 기준

- **공간 복잡도(Space Complexity)**
  - 특정 입력을 기준으로 알고리즘이 얼마나 많은 공간을 차지하는지
  - 평가 척도 : 알고리즘의 메모리 사용량

### 2. 💡 무엇인지 아는가(특징)

- **빅오 표기법 `O(n)`**
  - 복잡도를 표현하는 표기법 중 하나
  - 불필요한 상세를 무시하고 필수적인 부분에 집중하는 점근적 표기법
  - 어떤 함수의 입력 값에 따라 알고리즘의 실행 시간 및 공간 사용량이 어떻게 변하는지 설명

```java
// O(n) : n이 입력되면 n번 루프가 반복
for (int i = 0; i < n; i++) {...}

// O(n) : n이 무한에 가까울수록 k가 의미 없어짐(상수항과 계수 무시)
int k = 5;
for (int i = 0; i < n * k; i++) {...}

// O(n + m) : 입력값인 n과 m이 독립적
for (int i = 0; i < n; i++) {...}
for (int i = 0; i < m; i++) {...}

// O(n^2)
for (int i = 0; i < n; i++) {
	for (int j = 0; j < n * 5; j++) {}
}

// O(n^2) : 가장 큰 항 외에 무시 가능
for (int i = 0; i < n; i++) {}

for (int i = 0; i < n; i++) {
	for (int j = 0; j < n; j++)
}
```
