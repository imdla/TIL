> 💡 **한 줄 요약**
>
> 연관 관계가 설정된 엔티티 조회할 때, 예상치 못한 많은 수의 쿼리가 발생하는 현상으로, 로딩 전략은 예상 데이터 접근 패턴과 실제 접근 패턴이 달라 비효율적인 접근을 초래한다.
>
> 지연 로딩은 연관된 엔티티를 사용하는 시점에 추가 쿼리가 발생하고, 즉시 로딩은 원본 엔티티 조회 시 연관된 엔티티도 함께 조회해 많은 쿼리가 발생한다.
>
> 이를 해결하기 위해 첫번째로, 패치 조인은 쿼리 작성 시 연관된 엔티티를 함께 조회하도록 명시적으로 지정해, 원본 데이터와 연관된 엔티티를 한 번의 쿼리로 함께 조회할 수 있다.
>
> 두번째로, 엔티티 그래프는 엔티티 조회시 연관된 엔티티를 어떻게 로딩할지 미리 정의해 패치 조인보다 더 선언적이고 유연한 방식으로 연관 엔티티의 로딩 전략을 제어할 수 있다.

### 1. 🤔 무엇인가

- **N+1 문제란?**
    - 연관 관계가 설정된 엔티티를 조회할 경우, 조회된 데이터 개수(N)만큼 연관관계의 조회 쿼리가 추가로 발생하는 현상
    - 데이터베이스로부터 연관된 엔티티를 조회할 때 예상치 못한 많은 수의 쿼리 발생

- **즉시 로딩 (Eager Loading)**
    - 엔티티 조회할 때 연관된 엔티티도 함께 조회
    - **장점**
        - 연관된 엔티티 사용 시 추가 쿼리 발생하지 않음
        - 한 번의 쿼리로 필요한 데이터 모두 가져올 수 있음
    - **단점**
        - 불필요한 데이터도 함께 로딩되어 성능 저하
        - 연관관계 복잡한 경우 예측하기 어려운 쿼리 발생 가능

- **지연 로딩 (Lazy Loading)**
    - 연관된 엔티티를 실제 사용할 때 조회
    - 최초 엔티티 조회 시, 프록시 객체만 로딩
    - **장점**
        - 불필요한 데이터를 로딩하지 않아 초기 로딩 속도가 빠름
        - 메모리를 효율적으로 사용 가능
    - **단점**
        - 연관 엔티티를 사용하는 시점에 추가 쿼리 발생
        - 여러 연관 엔티티를 사용할 때, N+1 문제 발생 가능

⇒ 로딩 전략은 개발자가 예상하는 데이터 접근 패턴과 실제 애플리케이션의 데이터 접근 패턴이 다를 때 비효율적인 데이터 접근 초래

### 2. 💡 무엇인지 아는가(특징)

- **findAll 메서드의 글로벌 패치 전략별 N + 1 문제 상황**
    - 글로벌 패치 전략을 즉시 로딩으로 설정하고 findAll() 실행 시 N+1 문제 발생
    - findAll()은 `SELECT u FROM User u` 라는 JPQL 구문을 생성해서 실행하기 때문
    - JPQL은 글로벌 패치 전략을 고려하지 않고 쿼리를 실행함
    
    - **즉시 로딩 사용할 경우**
        - 모든 User를 조회하는 쿼리 실행 후, 즉시로딩 설정을 보고 연관관계에 있는 모든 엔티티를 조회하는 쿼리를 실행
        - 게시글과 댓글 관계에서 한꺼번에 PostList와 post마다 comments 조회
    - **지연 로딩 사용할 경우**
        - 글로벌 패치 전략을 지연 로딩으로 설정 후 findAll() 실행 시 N+1 문제 발생하지 않음
        - 연관관계에 있는 엔티티를 실제 객체 대신 프록시 객체로 생성해 주입하기 때문
        - 하지만 프록시 객체를 사용 시 실제 데이터가 필요해 조회하는 쿼리가 발생하고 N+1 문제 발생 가능
        - 게시글과 댓글 관계에서 comment를 사용할 때, post마다 comments를 조회
    
    ⇒ 즉시 로딩, 지연 로딩 관계 없이 N+1의 쿼리가 보내짐
    

### 3. 💪 해결 방법

1. **패치 조인 (fetch join)**
    - 연관 관계에 있는 엔티티를 한번에 즉시 로딩하는 구문
    - JPQL이나 Criteria API를 사용해 쿼리 작성 시 연관된 엔티티를 함께 조회하도록 명시적으로 지정
        
        → 원본 엔티티와 연관된 엔티티를 한 번의 쿼리로 함께 조회 가능
        
    - **장점**
        - 한 번의 SQL로 한 번에 로딩
    - **단점**
        - 동적 쿼리 작성 시 복잡해짐 → 해결 : 쿼리 DSL 사용
2. **엔티티 그래프 (@EntityGraph)**
    - 위와 비슷한 효과, 쿼리 메서드에 해당 어노테이션 추가해 사용 가능
    - 엔티티 조회 시 연관된 엔티티를 어떻게 로딩할지 미리 정의
    - **장점**
        - JPQL 없이 작성 가능
        - 패치 조인보다 더 선언적이고 유연한 방식의 연관 엔티티 로딩 전략 제어 가능
    - **단점**
        - 커스터마이징 어려움
