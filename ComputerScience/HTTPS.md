> 💡 **한 줄 요약**
>
> HTTP는 클라이언트와 서버 간 통신을 위한 통신 규약으로, 이는 암호화되지 않은 평문 데이터를 전송해 보안 측면에서 위험할 수 있다.
>
> HTTPS는 HTTP에 암호화가 추가된 규약으로, 암호화된 데이터를 전송해 제 3자가 볼 수 없도록 한다. 서버측에서 CA를 통해 인증서를 발급받아 HTTPS를 적용할 수 있다.

### 1. 🤔 왜 사용하는가

- **HTTP(Hypertext Transfer Protocol)**

  - 클라이언트와 서버 간 통신을 위한 통신 규약
  - **특징**
    - 비연결성(stateless) : 한 번의 요청-응답이 끝나면 연결이 종료됨
      - 통신이 안전하게 연결될 수 있도록 TCP 연결을 사용함
    - 다양한 데이터 포맷(HTML, JSON 등) 전달
      - 요청과 응답에는 URL 경로, 각종 메서드, 상태 코드와 헤더 등 정해진 몇 가지 정보를 포함
  - **단점** : 암호화되지 않는 평문 데이터 전송
    - 제 3자가 정보를 조회할 수 있음
      ⇒ **해결** : HTTPS 등장

- **HTTPS(Hypertext Transfer Protocol)**
  - HTTP에 데이터 암호화 추가
  - HTTP에 TLS/SSL 프로토콜에 따라 데이터를 암호화해 전송
  - 보안상 중요한 정보들을 안전하게 보호해 통신 주고 받음
    - 암호화된 데이터를 전송해 제 3자가 볼 수 없도록 함

### 2. 💡 무엇인지 아는가(특징)

> **HTTPS 적용 방법**

- **서버가 인증된 기관(Certificate Authority, CA)에게 인증서 발급 받음**
  ![image.png](/ComputerScience/assets/https_1.png)
  1. CA에 **인증서 요청**
  2. CA 이름, 서버 공개 키, 서버의 정보 활용 → **인증서 생성**
  3. 인증서를 **CA 개인 키로 암호화해 서버로 전송**
     - 인증서는 CA 개인 키로 암호화되어 신뢰성 확보 가능

> **HTTPS 동작 원리 (TLS 핸드 쉐이크)**

![image.png](/ComputerScience/assets/https_2.png)

1. **클라이언트 → 서버로 최초 요청**
   - 암호화 알고리즘, 프로토콜 버전, 난수를 함께 전달
2. **서버 → 클라이언트에게 응답**
   - 암호화 알고리즘, 인증서, 무작위 값 함께 전달
3. **클라이언트 - 서버의 SSL 인증서의 신뢰성 검증**
   - CA의 공개키(브라우저 내장)로 SSL 인증서를 복호화해 검증
4. **클라이언트 → 서버에 Pre Master Secret 생성 및 전송**
   - 검증 이후, 클라이언트와 서버에서 생성된 난수 조합
     → Pre Master Secret 생성
     → 서버의 공개키로 암호화해 전달
5. **서버 - 전달받은 암호화된 데이터를 개인키로 복호화해 Pre Master Secret 얻음**
6. **클라이언트와 서버 - 난수 2개와 Pre Master Secret로 대칭키 생성**
   - Pre Master Secret을 → Master Secret으로 변경
     → 해당 정보를 이용해 세션 키 생성
7. **클라이언트와 서버 - 세션 키 활용한 대칭키 암호화 방식의 데이터 송수신 수행**

> **RESTful API**

- **RSETful API**
  - REST(Representational State Transfer) 스타일을 준수하여 설계된 API
  - **REST** : 웹의 리소스를 클라이언트와 서버가 일관된 방식으로 처리할 수 있도록 하는 설계 원칙
    - 리소스 → 고유한 URI로 표현
    - 행위 → HTTP 메서드(GET, POST, PUT, DELETE 등) 사용
  - **핵심 규칙**
    - 클라이언트-서버 분리 : 클라이언트와 서버 간 역할을 명확히 분리
    - 무상태성(Stateless) : 서버는 클라이언트의 상태를 저장하지 않으며, 각 요청은 독립적으로 처리
    - 일관된 인터페이스(Uniform Interface) : 고유한 URI로 리소스를 식별하고 일관된 인터페이스를 통해 클라이언트와 서버가 간단하고 예측 가능하게 통신할 수 있게 함
    - 캐시 가능성 : 가능하다면, 서버의 응답 시간을 개선하기 위해 리소스 캐싱 지원
