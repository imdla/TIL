> 💡 **한 줄 요약**
>
> 단일 책임 원칙은 하나의 클래스는 하나의 책임만 가지는 것으로 `토끼`라는 객체가 있을 때 클래스 내부에 `먹다`와 `뛰다`라는 메서드를 직접 가지는 것이 아니라 추상화된 인터페이스를 구현하는 것을 통해 `토끼` 객체의 재사용성과 유지보수성을 향상시킬 수 있다.
>
> 개방-폐쇄 원칙은 구성 요소는 확장에는 열려 있지만 변경에는 닫혀있는 것으로 기존의 코드를 변경하지 않고 기능 추가를 할 수 있어야 한다. 위의 `토끼`의 예에서 `먹다` 의 인터페이스가 `풀을먹다` 라는 클래스로 구현하고 `토끼.먹다` 로 호출한다. 이렇게 만들 경우 나중에 `당근을먹다` 라는 클래스 생성 시 `토끼` 클래스에 변경 없이도 `당근`을 먹는 기능을 추가할 수 있다.
>
> 리스코프 치환 원칙은 상위 클래스 객체가 사용하는 메서드는 하위 클래스에서도 사용할 수 있는 것으로, `동물` 클래스에서 `먹다` 라는 메서드가 있을 때 `토끼` 는 동물 클래스를 extends해 `먹다` 라는 기능을 사용할 수 있고, `동물` 클래스를 extends한 여러 클래스들이 있을 때 `동물.먹다` 의 기능에서 동물을 하위 클래스명으로 바꾸어도 사용 가능하다.
>
> 인터페이스 분리 원칙은 클라이언트 자신이 사용하지 않는 인터페이스에 의존하면 안되는 것으로, `먹다` , `자다` , `뛰다` 의 인터페이스를 각각 생성해 `동물`이나 `토끼` 클래스에 구현함으로써 의존성을 줄일 수 있다.
>
> 의존 관계 역전 원칙은 고수준 모듈은 저수준 모듈에 의존해서는 안되고, 둘 다 추상화에 의존해야 하는 것으로, 구체화에 의존하지 않고 추상화에 의존하는 것이다.

### 1. 🤔 왜 사용하는가

- **단일 책임 원칙 (Single Responsibility Prinsiple)**

  - 하나의 클래스는 하나의 책임만 가짐
  - 클래스의 변경 이유는 단 하나
  - 장점
    - 클래스 변경 이유 명확
    - 시스템 복잡성 감소
    - 재사용성, 유지보수성 향상

- **개방-폐쇄 원칙 (Open-Closed Principle)**

  - 소프트웨어 구성요소(클래스, 모듈, 함수 등)는 확장에는 열려 있지만 변경에는 닫혀 있어야 함
  - 기존의 코드를 변경하지 않고 기능 추가 할 수 있어야 함
  - 원칙 지키기 위한 방법
    - 상속과 다형성이 확장에 열려 있도록 만듦
    - 추상화는 변경에 닫혀있도록 만듦
  - 장점
    - 유연성, 확장성 향상

- **리스코프 치환 원칙 (Liskov Substitution Prinsiple)**

  - 서브 타입은 언제나 그것의 베이스 타입으로 교체 가능
  - 상위 클래스의 객체가 사용하는 메서드는 하위 클래스의 객체가 무엇인지 상관없이 하위 클래스의 객체도 사용할 수 있어야 한다.
  - 장점
    - 다형성을 통한 유연한 설계 가능

- **인터페이스 분리 원칙 (Interface Segregation Principle)**

  - 클라이언트는 자신이 사용하지 않는 인터페이스에 의존하면 안됨
  - 하나의 일반적인 인터페이스보다는 여러 개의 구체적인 인터페이스가 좋음
  - 장점
    - 필요한 인터페이스만 구현해 불필요한 의존성 줄임
    - 시스템의 유연성 향상

- **의존 관계 역전 원칙 (Dependency Inversion Principle)**
  - 구체화에 의존하지 말고 추상화에 의존함
  - 고수준 모듈은 저수준 모듈에 의존해서는 안되며, 둘 다 추상화에 의존해야 함
