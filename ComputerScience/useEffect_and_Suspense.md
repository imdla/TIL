> 💡 **한 줄 요약**
>
> 기존 로딩 상태 관리 방식은 `useEffect()` 라는 훅을 사용해 데이터를 불러오고, 로딩 상태를 관리하기 위해 `isLoading` 이라는 별도의 상태 변수를 만들어서 관리한다. 이는 간단하지만 여러 개의 비동기 데이터를 다룰 때는 조건부 렌더링 로직이 복잡해질 수 있다.
>
> `Suspense` 는 로딩 중인 컴포넌트를 직접 렌더링하지 않고, 데이터를 기다리는 동안 `Suspense` 컴포넌트의 `fallback` 속성으로 로딩 UI만 보여주고, 데이터가 모두 준비되면 `Suspense` 로 감싸진 컴포넌트를 자연스럽게 표시한다.

### 1. 🤔 왜 사용하는가

- **`useEffect()`**
  - 데이터를 불러올 때 `useEffect()` 훅을 사용
    - 로딩 상태 관리 위해 `isLoading` 이라는 별도의 상태 변수 생성 필요
  - **장점** : 간단한 상황에서 충분히 유효
  - **단점** : 여러 개의 비동기 데이터를 다룰 때는 조건부 렌더링 로직이 복잡
- **`Suspense`**
  - 로딩 중인 컴포넌트를 직접 렌더링하지 않고, `Suspense` 컴포넌트의 `fallback` 속성으로 로딩 UI를 정의하게끔 함
    1. 데이터를 기다리는 동안 `fallback` 으로 정의된 UI만 보여줌
    2. 데이터 모두 준비되면 `Suspense` 에 감싸진 컴포넌트를 자연스럽게 표시함
  - **장점** : 로딩 상태를 선언적으로 관리 → 코드 단순 및 유지보수 쉬움

### 2. ⚠️ `Suspense` 단점

- 여러 개의 `Suspense` 컴포넌트를 **중첩 및 트리 구조**로 사용할 경우
  - 각 `Suspense` 가 독립적으로 로딩 상태를 관리해 데이터 준비 시점이 다를 수 있음
  - 그 결과 로딩 화면이 여러 번 표시되거나 비일관적인 UI 경험 발생 가능
- **`Suspense` 는 `Promise` 기반의 비동기 작업만 지원**
  - 일반적인 `fetch` 요청에 바로 적용할 수 없음
  - 추가적인 라이브러리 사용 및 `Suspense` 와 호환되는 형태로 `Promise` 관리 필요
