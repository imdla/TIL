> 💡 **한 줄 요약**
>
> 공유 락과 배타 락은 비관적 락의 데이터 일관성과 무결성을 위해 사용하는 락 유형이다.
>
> 공유 락이 걸린 데이터는 읽기 연산만 가능해 쓰기 연산은 불가능하며, 트랜잭션 내 조회한 데이터가 변경되지 않음을 보장한다.
>
> 배타 락을 획득한 트랜잭션은 읽기, 쓰기 연산 모두 가능하지만 다른 트랜잭션에서는 불가능하며, 이를 획득한 트랜잭션은 데이터에 대한 독점권을 가진다.
>
> 배타 락 사용 시 데드 락이 발생할 수 있는데, 데드 락이란 교착 상태로 두 개 이상의 트랜잭션이 서로 필요로 하는 데이터의 락을 점유하고 있어 무한히 대기하는 상황이다. 이를 해결하기 위해서는 락 획득 순서를 일관되게 하거나 락 타임 아웃을 설정할 수 있다.

### 1. 🤔 왜 사용하는가

- **공유 락 & 배타 락 사용 이유**

  - 비관적 락(Pessimistic Lock)의 데이터 일관성과 무결성 위해 사용

- **공유 락 (Shared Lock)**

  - (= 읽기 락, Read Lock)
  - 공유 락이 걸린 데이터는 읽기(SELECT) 연산만 가능
  - 쓰기 (UPDATE, DELETE)는 불가능
  - 공유 락이 걸린 데이터에 대해 다른 트랜잭션에서도 공유 락을 획득 가능, 배타 락은 획득 불가
  - 공유 락 사용 시 트랜잭션 내에서 조회한 데이터가 변경되지 않음을 보장

  ```sql
  SELECT * FROM table_name WHERE id = 1 FOR SHARE;
  ```

- **배타 락 (Exclusive Lock)**
  - (= 쓰기 락, Write Lock)
  - 배타 락을 획득한 트랜잭션은 읽기, 쓰기 연산 모두 가능
  - 다른 트랜잭션에서는 읽기, 쓰기 모두 불가능
  - 배타 락을 획득한 트랜잭션은 데이터에 대한 독점권 가짐
  ```sql
  SELECT * FROM table_name WHERE id = 1 FOR UPDATE;
  ```

### 2. 💡 무엇인지 아는가(특징)

- **배타 락 사용시 데드 락이 발생하는 상황**

  ![deadLock.png](/ComputerScience/assets/deadLock.png)

- **데드 락 (Dead Lock)**

  - 교착 상태
  - 두 개 이상의 트랜잭션이 서로 필요로 하는 데이터의 락을 점유하고 있어 무한히 대기하는 상황
  - 트랜잭션은 락을 획득하지 못하는 경우, 다른 트랜잭션이 점유하고 있는 락이 해제될 때까지 기다림
  - 두 개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리고 있어 결과적으로 아무것도 완료되지 못하는 상태

- **교착 상태 발생 조건**

  - 4가지 조건(상호 배제, 점유 대기, 비선점, 원형 대기)이 모두 만족하는 경우, 교착 상태에 빠질 수 있음

  1. **상호 배제(mutual exclusion)**
     - 한 프로세스가 사용하는 자원을 다른 프로세스가 사용할 수 없는 경우
  2. **점유대기(hold and wait)**
     - 자원을 할당받은 상태에서 다른 자원을 할당받기를 기다리는 상태
  3. **비선점(non-preemption)**
     - 자원이 강제적으로 해제될 수 없으며 점유하고 있는 프로세스의 작업이 끝난 이후에만 해제되는 것
  4. **원형 대기(circular wait)**
     - 프로세스들이 원의 형태로 자원을 대기하는 것

- **데드 락 해결 방법**
  1. 트랜잭션에서 락 획득 순서 일관되게 함
     - 모든 트랜잭션에서 1번 데이터, 2번 데이터 순으로 락 획득 시 데드 락 발생하지 않음
  2. 락 타임 아웃 설정
  - `ReentrantLock` 을 사용하는 경우
    - `tryLock()` 메서드 사용해 타임아웃 설정
  - `lockInterruptibly()` 메서드 사용하는 경우
    - 인터럽트 통해 스레드 깨움
  - 교착 상태가 발생하는 4가지 조건 중 하나를 충족하지 못하거나, 대기하는 경우 무한정 기다리지 않는 방식으로 교착 상태 풀 수 있음
