> 💡 **한 줄 요약**
>
> 경쟁 상태는 두 개 이상의 스레드가 공유 자원에 동시 접근할 경우 스레드 간 실행 순서에 따라 결과가 달라지는 현상으로, 이는 원자성과 가시성 모두 보장되어야 해결할 수 있다.

### 1. 🤔 왜 사용하는가

- **경쟁 상태(Race Condition)**

  - 두 개 이상의 스레드가 공유 자원에 동시에 접근할 때 스레드 간의 실행 순서에 따라 결과가 달라지는 현상
  - 원자성과 가시성 모두 보장되어야 해결 가능

- **원자성(Atomicity)**

  - 공유 자원에 대한 작업의 단위가 더 이상 쪼갤 수 없는 하나의 연산처럼 동작하는 성질

- **가시성(Visibility)**
  - 한 스레드에서 변경한 값이 다른 스레드에서 즉시 확인 가능한 성질

### 2. 💡 무엇인지 아는가(특징)

> **원자성을 보장하지 않을 경우 발생하는 문제**

- `i++` 연산
  - 하나의 문장이지만, CPU가 이를 수행하기 위해 세 단계의 instruction으로 분리
    1. `i` 변수의 기존 값 읽음 (Read)
    2. 기존 값에 1을 더함 (Modify)
    3. 결과 값을 다시 `i` 변수에 할당 (Write)
  - 연산 사이에 다른 스레드가 개입할 경우 기대하지 않은 결과 발생 가능
- 두 개의 스레드가 동시에 `i++` 연산 수행 시
  - `Thread 1` 이 i + 1을 하기 전에, `Thread 2` 가 i를 읽어 i + 1을 수행 후 반영하면 `Thread 2` 의 연산은 무시됨

> **가시성을 보장하지 않을 경우 발생하는 문제**

- 현대의 컴퓨터 - 여러 개의 CPU 코어가 있고, 코어마다 CPU 캐시 존재
- 한 스레드에서 공유 자원을 변경할 경우
  - 메인 메모리에서 CPU 캐시로 값을 읽어들인 후,
    변경된 값을 자신의 CPU 캐시에 반영
- 하지만, 변경된 값이 메인 메모리에 언제 반영될지 알 수 없음
  - 다른 스레드가 공유 자원을 읽을 때 변경 사항을 즉시 확인 불가

> **JAVA에서 원자성과 가시성을 보장하기위한 방법**

- **원자성과 가시성 모두 보장 시**
  - `synchronized` 키워드
  - CAS(Compare-And-Swap) 알고리즘 사용하는 `Atomic` 클래스
  - `ReentrantLock` 과 같은 lock 클래스
  - Concurrent Collections 등
- **가시성만 보장 시**
  - `volatile` 키워드
    - CPU 캐시를 사용하지 않고 메인 메모리에서 공유 자원을 직접 읽거나 쓸 수 있음
    - 하나의 스레드에서만 쓰기 작업 수행, 나머지 스레드는 읽기 작업만 수행
