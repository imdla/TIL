> 💡 **한 줄 요약**
>
> 인덱스는 데이터베이스의 효율적인 검색을 위해 트리 구조로 구현해 데이터를 배치하고 정렬한 컬럼이다.
>
> 트리 구조로 구현해 반씩 소거해 나가며 검색할 수 있어 효율적인 데이터 검색을 할 수 있다.
>
> 하지만 컬럼을 복사해 정렬하므로 인덱스 생성 시 마다 데이터베이스 용량이 증가할 수 있다.

### 1. 🤔 왜 사용하는가

- 효율적인 검색 위해 정렬된 컬럼
- 데이터베이스에서 효율적인 데이터 검색을 도와주는 자료구조
  - 전체 데이터를 살펴보지 않고도 원하는 데이터 접근 가능

### 2. 💡 무엇인지 아는가(특징)

- **특징**

  - 저장되는 컬럼의 값을 사용해 항상 정렬된 상태를 유지
  - 트리 구조를 반씩 나누어가며 검색해 효율적인 검색 가능

- **구현 방식**

  - 트리 구조로 구현해 데이터 배치 및 정렬

  1. **B-tree**
     - 노드에 하나의 데이터 저장
     - 컬럼의 값을 변형하지 않고 인덱스 구조체 내에서 항상 정렬된 상태 유지
     - **노드 3가지 종류**
       - 루트 노드 : 최상위, 1개, 실제 데이터 레코드 찾아가기 위한 주소값 가지고 있음
       - 리프 노드 : 가장 하위 노드
       - 브랜치 노드 : 루트 노드와 리프 노드의 중간에 존재
  2. B+tree
     - 노드에 여러 개의 데이터 저장
     - 데이터를 최하위 노드에만 보관하고, 상위 노드는 데이터 탐색을 위한 가이드라인 제공
     - 리프 노드(데이터 노드)만 인덱스와 데이터(value) 가짐, 나머지 노드(인덱스 노드)는 데이터를 위한 인덱스(key)만 가짐
       - 리프 노드들은 LinkedList로 연
     - 범위 검색 용이

- **MySQL 스캔 방식**
  - **인덱스 레인지 스캔**
    - 검색할 인덱스 범위가 경정되었을 경우 사용, 가장 빠름
    1. 인덱스에서 조건을 만족하는 값이 저장된 시작 리프 노드 찾음 (index seek)
    2. 시작 리프 노드부터 필요한 만큼 인덱스를 차례대로 읽음 (index scan)
    3. 인덱스 키와 레코드 주소를 이용해 저장된 페이지를 가져오고 레코드를 읽어옴
    - 레코드 읽어오는 과정에서 랜덤 IO가 발생할 수 있음
  - **인덱스 풀 스캔**
    - 인덱스를 사용하지만 인덱스를 처음부터 끝까지 모두 읽음
    1. 인덱스를 ABC 순서로 만들었는데 조건절에 B 혹은 C로 검색하는 경우 사용
    2. 인덱스를 생성하는 목적은 아니지만, 풀 테이블 스캔보다는 효과적
  - **루스 인덱스 스캔**
    - 듬성듬성 인덱스를 읽는 것
    1. 중간에 필요하지 않은 인덱스 키 값은 무시하고 다음으로 넘어가는 형태로 처리
    2. group by, max(), min() 함수에 대해 최적화하는 경우 사

### 3. ✅ 장점

- 검색 속도 향상
- 전반적인 시스템 부라 줄일 수 있음
- 검색 작업 필요 없는 컬럼들에는 인덱스 만들 필요 없음
- PK로 설정된 컬럼은 자동으로 정렬되어 별도로 인덱스 만들 필요 없음

### 4. ⚠️ 단점

- 컬럼을 복사해 정렬하는 것으로, 인덱스 만들 때 마다 DB 용량 증가
- 기존 테이블에 있는 데이터 변경 시 인덱스에도 변경 사항 반영 필요
- 인덱스 관리 위해 추가 작업 필요
