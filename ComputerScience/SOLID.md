> 💡 **한 줄 요약**
>
> 객체지향 설계 5원칙인 SOLID 원칙의 핵심 중 하나는 의존성을 관리하는 것이다. 의존성을 잘 관리하기 위해 SOLID 원칙을 준수해야 한다.
>
> 단일 책임 원칙은 클래스가 오직 하나의 목적이나 이유로만 변경되어야 하는 것이다. 개방 폐쇄 원칙은 확장에는 열려있고, 변경에는 닫혀 있어야 한다. 리스코프 치환 원칙은 서브 타입은 언제나 상위 타입으로 교체할 수 있어야 한다. 인터페이스 분리 원칙은 클라이언트에서 인터페이스를 분리해야 하는 것입니다. 의존성 역전 원칙은 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안되며, 모두 추상화에 의존해야 한다는 것입니다.

### 1. 🤔 왜 사용하는가

> **SOLID 원칙 (객체지향 설계 5원칙)**

- 객체지향설계의 핵심 중 하나는 의존성 관리

1. **단일 책임 원칙 (Single Responsibility Principle)**

   - 클래스가 오직 하나의 목적, 이유로만 변경되어야 함
     - 클래스는 한 가지 변화의 이유만 가짐
     - 변경이 발생했을 때 **다른 기능에 영향을 더 미치도록 설계**
   - _“책임”_ : 특정 사용자나 기능 요구사항에 따라 소프트웨어의 변경 요청을 처리하는 역할
   - 장점 : 유지보수 쉬워짐, 코드 이해하기 쉬움

1. **개방 폐쇄 원칙(Open-Closed Principle)**

   - 확장에는 열려있고, 변경에는 닫혀 있음
   - _“확장”_ : 새로운 타입을 추가함으로써 새로운 기능을 추가하는 것
   - _“폐쇄”_ : 확장이 일어날 때 상위 레벨의 모듈이 영향을 받지 않아야 함
   - 장점 : 모듈의 행동을 쉽게 변경 가능
     - 모듈 : 크기와 상관없이 클래스, 패키지, 라이브러리와 같이 프로그램을 구성하는 임의의 요소

1. **리스코브 치환 원칙 (Liskov Substitution Principle)**

   - 서브 타입은 언제나 상위 타입으로 교체 가능
     - 서브 타입은 상위 타입이 약속한 규약을 지켜야 함
   - 부모 쪽으로 업 캐스팅하는 것이 안전함을 보장하기 위해 존재
     - 상위 타입에 대해 기대되는 역할과 행동 규약을 벗어나면 안됨
     - 하위 타입이 상위 타입에 기대되는 역할에 만족하지 않을 경우
       - 상위 타입을 사용하는 클라이언트 코드에서는 하위 타입이 누구인지 물어봐야 함
         ⇒ OCP 달성을 어렵게 함
   - LSP 위반하는 대표적 사례 : Rectangle

1. **인터페이스 분리 원칙 (Interface Segreation Principle)**

   - 클라이언트 입장에서 인터페이스를 분리해야 함
     - 사용하지 않지만, 의존성 가지고 있다면 해당 인터페이스가 변경되는 경우 영향을 받음
       ⇒ 독립적인 개발 및 배포 불가함
   - 사용하는 기능만 제공하도록 인터페이스 분리
     - 변경의 여파 최소화 가능

1. **의존성 역전 원칙 (Dependency Inversion Principle)**
   - 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안되며, 모두 추상화에 의존해야 함
   - 의존성 역전 원칙 통해 하위 레벨의 모듈은 개방 폐쇄 원칙을 준수하며, 새로운 타입 추가 가능
