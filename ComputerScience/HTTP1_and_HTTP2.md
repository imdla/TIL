> 💡 **한 줄 요약**
>
> HTTP는 웹 상에서 클라이언트와 서버 간 통신을 위한 프로토콜이다. HTTP/1.0은 한 개의 요청과 응답마다 TCP 커넥션을 생성해 사용해, 매 요청마다 연결을 생성하는 오버헤드 발생한다.
>
> HTTP/1.1은 위 문제를 지속 커넥션이라는 지정한 타임아웃만큼 커넥션을 종료하지 않는 방식으로 해결한다. 또한, 요청이 연속적이고 순차적으로 전달되는 파이프라이닝을 지원해 요청의 응답 지연을 감소한다. 하지만, HOL Blocking으로 첫 번째 요청이 오래 걸리면 나머지 요청은 첫 번째 요청의 처리를 기다리거나, 매 요청마다 동일한 헤더를 반복해 전송한다는 문제점이 있다.
>
> HTTP/2.0은 HTTP 메시지를 프레임이라는 단위로 분할 및 바이너리 형태로 만들어서 전송해, 파싱 및 전송 속도가 향상 되었다. 멀티플렉싱을 지원해 하나의 커넥션을 사용해 요청과 응답을 병렬적으로 처리할 수 있어 HOL Blocking 문제를 해결할 수 있다. HPACK 헤더 압축 방식을 사용해 반복되는 헤더를 효율적으로 관리해 대역폭 사용이 최적화 되었다.

### 1. 🤔 왜 사용하는가

> **HTTP**

- 웹 상에서 클라이언트와 서버 간 통신을 위한 프로토콜

> **HTTP/1.0**

- 한 개의 요청과 응답마다 TCP 커넥션을 생성해 사용
- **단점 :** 매 요청마다 연결을 생성하는 오버헤드 발생

> **HTTP/1.1**

- 메시지 전송 형식 : 일반 텍스트 형식
- **장점**
  1. **지속커넥션 (Persistent Connection)**
     - 지정한 타임아웃만큼 커넥션을 종료하지 않는 방식
       → HTTP/1.0의 단점을 해결
  2. **파이프라이닝 (Pipelining) 지원**
     - 요청의 응답 지연 감소
     - HTTP 요청 연속적, 순차적 전달
       - 기존 → 요청한 이후 응답을 기다리고 그 다음 요청 보냄
       - 파이프라이닝 → 필요한 모든 자원에 대한 요청을 순차적으로 서버로 전송 후 모든 요청에 대한 응답을 한 번에 기다림
- **단점**
  1. **Head-of-Line Blocking (HOL Blocking) 문제**
     - ex. 3개의 요청을 파이프라인 통해 전송할 경우
       - 서버는 모든 요청을 순서에 맞춰 응답해야 함
       - 첫 번째 요청이 오래 걸리면, 나머지 요청은 첫 번째 요청의 처리 기다림
  2. **동일한 헤더를 반복하여 전송함**

> **HTTP/2.0**

- 전송 형식 : 프레임
  - 프레임 단위로 분할 및 바이너리 형태로 만들어 전송
  - 기존보다 파싱 및 전송 속도 향상

1. **멀티플렉싱(Multiplexing)**
   - 하나의 커넥션을 사용해 요청과 응답을 병렬로 처리 가능
   - 클라이언트가 서버로 여러 요청을 동시에 보내도 각 요청이 독립적으로 처리되어 애플리케이션 레이어의 HOL Blocking 문제를 해결
2. **HPACK 헤더 압축 방식 사용**
   - 반복되는 헤더를 효율적으로 관리
   - 대역폭 사용이 최적화됨
