> 💡 **한 줄 요약**
>
> CSRF 공격은 사용자가 자신의 의지와 상관없이 공격자가 의도한 행위를 특정 웹사이트에 요청하도록 하는 것이다.

### 1. 🤔 왜 사용하는가

- **사이트 간 요청 위조(Cross-site Request Forgery, CSRF) 공격**
  - 사용자가 자신의 의지와 상관없이 공격자가 의도한 행위를 특정 웹사이트에 요청하도록 하는 것
  - ex. 특정 사용자가 서비스에서 로그인을 수행
    1. 서버는 해당 사용자에 대한 세션 ID를 `Set-Cookie` 헤더에 담아 응답
    2. 클라이언트는 쿠키를 저장하고 요청마다 자동으로 전달
    3. 사용자를 대상으로 공격자는 악성 스크립트 담긴 페이지에 접속하도록 유도
       - 유도 방법
         - 악성 스크립트 포함된 메일 및 게시글 작성
         - 악성 스크립트 포함된 공격자 사이트 접속 링크 전달 등
    4. 사용자가 악성 스크립트 포함된 페이지 접속 시 악성 스크립트 실행
       - 악성 스크립트는 의도와 상관없는 특정한 요청을 공격 대상 서버로 보냄
       - 해당 요청은 브라우저에 의해 자동으로 쿠키에 저장된 세션 ID가 함께 전달됨

### 2. 💡 무엇인지 아는가(특징)

> **CSRF 공격의 방어 → 교차 출처인 상황에서 요청을 막는 방식**

1. **HTTP 헤더 중 하나인 Referer 요청 헤더 사용**
   - Referer 요청 헤더로 현재 요청을 보낸 페이지의 주소 알 수 있음
   - 해당 주소와 Host(서버의 도메인 이름) 헤더를 비교해 다른 경우, 예외 발생 가능
   - **단점** : Referer 요청 헤더는 조작될 수 있음
2. **템플릿 엔진 기술(JSP, 타임리프, Pug, Ejs 등) 사용하고 있을 경우 CSRF 토큰 사용**
   - 페이지 생성 이전 사용자 세션에 임의의 CSRF 토큰을 저장
   - 특정 API 요청에 대한 제출 폼 생성 시 해당 CSRF 토큰값이 설정된 input 태그 추가
   - 실제 요청 전달될 때, 해당 input 태그의 CSRF 토큰과 사용자 세션 내부에 존재하는 CSRF 토큰의 일치 여부 판단해 CSRF 공격 방어 가능
3. **SameSite 쿠키**
   - 크로스 사이트에 대한 쿠키 전송 제어
4. **브라우저의 SOP(Same Origin Policy) 정책 사용**
   - CORS 설정으로 교차 출처 접근을 일부분 허용
