## <mark color="#fbc956">비트 연산</mark>

### 1. 비트 연산

- 0과 1로 표현되는 비트를 이용한 모든 연산 의미
  - 0 : 비트가 꺼진 상태
  - 1 : 비트가 켜진 상태
- 컴퓨터는 비트 단위로 연산을 해 비트 연산은 매우 빠른 연산 속도를 보장

### 2. 이진법

- 0과 1로 표현되는 숫자 체계
  | 십진수 | 이진수 |
  | ------ | ------ |
  | 0 | 0 |
  | 1 | 1 |
  | 2 | 10 |
  | 3 | 11 |
  | 4 | 100 |
  | 5 | 101 |
  | 6 | 110 |
  | 7 | 111 |
  | 8 | 1000 |
- 십진수를 이진수로 변환하는 과정
  - 이진수의 각 자리수는 2의 거듭제곱으로 계산
  - $7 = 2^2 + 2^1 + 2^0 ⇒ 111_2$
- 파이썬에서 `bin()` 함수

  - 이진수 형태 확인 가능
  - 타입은 문자열로 변환됨
  - 이진수는 앞에 0b가 붙어 해당 숫자가 이진수임을 나타냄

  ```python
  num = bin(5)

  print(num)       # 0b101
  print(type(num)) # <class 'str'>
  ```

### 3. 비트 연산자

- 비트 연산은 십진수가 대상이라도, 그에 대응되는 이진수를 위 아래로 비교함

| 연산자 종류 | 효과         | 수식   |
| ----------- | ------------ | ------ | --- | --- |
| &           | and          | a & b  |
|             |              | or     | a   | b   |
| <<          | 왼쪽 shift   | a << n |
| >>          | 오른쪽 shift | a >> n |
| ^           | xor          | a ^ b  |
| ~           | not          | ~a     |

- **`& (and)`**

  - 비교하고자 하는 비트가 둘 다 1인 경우 1로, 하나라도 0이면 0으로 계산

  ```python
  print(6 & 3) # 2

  # 1 1 0 => 6
  # 0 1 1 => 3
  # -----&-----
  # 0 1 0 => 2
  ```

- **`| (or)`**

  - 비교하고자 하는 비트 중 하나라도 1이면 1로 계산, 모두 0이면 0으로 계산

  ```python
  print(6 | 3) # 7

  # 1 1 0 => 6
  # 0 1 1 => 3
  # -----|-----
  # 1 1 1 => 7
  ```

- **`<< (왼쪽 shift)`**

  - 비트를 왼쪽으로 n칸 이동시킴, 새로 생신 부분은 0으로 계산

  ```python
  # 왼쪽으로 한 칸 & 두 칸 이동
  print(7 << 1) # 14
  print(7 << 2) # 28

  # 1 1 1
  # -----<<-----
  # 1 1 1 0 => 14
  # -----<<-----
  # 1 1 1 0 0 => 28
  ```

  - 비트를 1칸 왼쪽으로 이동시킬 때 마다, 십집수 기준으로 2배씩 증가함

- **`>> (오른쪽 shift)`**

  - 비트를 오른쪽으로 n칸 이동시킴, 오른쪽으로 없어진 부분은 삭제

  ```python
  # 오른쪽으로 이동
  print(7 >> 1) # 3 (7을 2로 나눈 몫)
  print(27 >> 2) # 6 (27을 4로 나눈 몫)
  print(415 >> 4) # 25 (415를 16으로 나눈 몫)
  ```

  - 비트를 1칸 오른쪽으로 이동시킬 때 마다, 십진수 기준으로 2로 나눈 몫이 됨

- **`^ (xor)` (exclusive or, 배타적 논리쌍)**

  - 비교하고자 하는 비트가 서로 다르면 1로, 같으면 0으로 계산

  ```python
  print(6 ^ 3) # 3

  # 1 1 0 => 6
  # 0 1 1 => 3
  # ----^-----
  # 1 0 1 => 5
  ```

- **`~ (not)`**
  - 해당 비트를 모두 반전시킴
  - 1은 0으로, 0은 1로 변환

---

## <mark color="#fbc956">비트 연산 활용</mark>

### 1. 비트마스킹

- 0과 1로 이루어진 비트들을 일종의 자료구조처럼 활용하는 기법
- 실제 숫자를 활용할 수 있고, 0과 1로만 이루어진 리스트를 활용할 수 있음
- 알고리즘 문제에서는 그래프 탐색에서 방문기록지를 집합이 아닌 비트마스킹 활용해 표현 가능

### 2. 부분집합 구하기

- 비트 shift 활용해 부분집합 코드 구현 가능

```python
# 비트 활용한 부분집합 구하기
letters = ['a', 'b', 'c']

# 총 2^3, 8개의 경우의 수 체크
for i in range(1 << len(letters)):
	selected = []
	# 각 비트를 한 칸씩 옮기며 대조
	for j in range(len(letters)):
		# 1칸씩 왼쪽으로 옮겨가며 총 3칸 대조
		if i & (1 << j):
			# 대조 결과가 성공이라면 selected에 append
			selected.append(letters[j])

	print(selected)

# []              | => (i = 0) => 0 0 0 => 공집합
# ['a']           | => (i = 1) => 0 0 1 => (j = 0)에 걸려 'a' 뽑힘
# ['b']           | => (i = 2) => 0 1 0
# ['a', 'b']      | => (i = 3) => 0 1 1
# ['c']           | => (i = 4) => 1 0 0 => (j = 2)에 걸려 'c; 뽑힘
# ['a', 'c']      | => (i = 5) => 1 0 1
# ['b', 'c']      | => (i = 6) => 1 1 0
# ['a', 'b', 'c'] | => (i = 7) => 1 1 1
```
