## <mark color="#fbc956">Tree</mark>

### 1. Tree

- 비선형 자료구조, **사이클이 없는 무방향 그래프**
  - 노드 : V개
  - 간선 : E개 (V-1)

### 2. 용어

- **루트 노드** : 트리의 최상단 노드
- **리프 노드** : 자식이 없는 말단 노드
- **형제 노드** : 같은 부모를 가지는 노드
- **차수** : 특정 노드가 가지는 자식 노드의 개수
- **레벨** : 루트 노드로부터 특정 노드까지 도달할 때 거치는 간선의 개수(깊이)

### 3. 트리의 표현

- **전체 자료구조 포함 관계도**

  (그래프 > 트리 > 이진트리 > 완전이진트리 > 힙 자료구조)

  > 그래프
  >
  > > 트리
  > >
  > > > 이진트리
  > > >
  > > > > 완전이진트리
  > > > >
  > > > > > 힙자료구조

- **상위 표현 방식으로 하위 카테고리 표현 가능**
  1. **트리는 그래프와 같이 인접 행렬, 인접 리스트로 표현 가능**
     - 인접 행렬로 트리 표현
       ```python
       [[0, 0, 1, 1, 1, 0],  # 0번 노드 => 2, 3, 4번 노드와 연결
        [0, 0, 0, 0, 0, 1],  # 1번 노드 => 5번 노드와 연결
        [1, 0, 0, 0, 0, 0],  # 2번 노드 => 0번 노드와 연결
        [1, 0, 0, 0, 0 ,1],  # 3번 노드 => 0, 5번 노드와 연결
        [1, 0, 0 ,0, 0, 0],  # 4번 노드 => 0번 노드와 연결
        [0, 1, 0, 1, 0, 0]]  # 5번 노드 => 1, 3번노드와 연결
       ```
     - 인접 리스트로 트리 표현
       ```python
       [[2, 3, 4], [5], [0], [0, 5], [0], [1, 3]]
       ```
  2. **트리에서만 사용 가능한 표현**
     - 자식 노드 인덱스에 부모 노드의 번호 저장해 하나의 리스트 생성
       | Index (자식) | 0 | 1 | 2 | 3 | 4 | 5 |
       | ------------ | --- | --- | --- | --- | --- | --- |
       | Parent | 3 | 5 | 0 | - | 0 | 3 |

---

## <mark color="#fbc956">이진 트리</mark>

### 1. 이진 트리

- 자식의 최대 개수가 2개인 트리
- 표현 방식
  - **key** : 행의 갯를 줄여 단 두개의 선형 자료 구조로 표현
    - 부모 노드의 인덱스에 자식 노드의 번호 저장
  - **Left 배열** : 왼쪽 자식 노드의 번호 저장
  - **Right 배열** : 오른쪽 자식 노드의 번호 저장
    (자식 노드가 없는 경우 리프노드 의미)
    | Index (부모) | 0 | 1 | 2 | 3 | 4 | 5 |
    | ------------ | --- | --- | --- | --- | --- | --- |
    | Left | 2 | - | - | 5 | - | 1 |
    | Right | 4 | - | - | 0 | - | - |

### 2. 이진 트리의 순회

- **전위 순회 (루트 → 왼쪽 → 오른쪽)**

  - 폴더 구조

  ```python
  def preorder(node):
  	if node == -1:
  		return

  	print(node, end=" ")
  	preorder(tree[node][0])
  	preorder(tree[node][1])
  ```

- **중위 순회 (왼쪽 → 루트 → 오른쪽)**

  - 이진검색트리

  ```python
  def inorder(node):
  	if node == -1:
  		return

  	inorder(tree[node][0])
  	print(node, end=" ")
  	inorder(tree[node][1])
  ```

- **후위 순회 (왼쪽 → 오른쪽 → 루트)**

  - 후위 연산식

  ```python
  def postorder(node):
  	if node == -1:
  		return

  	postorder(tree[node][0])
  	postorder(tree[node][1])
  	print(node, end=" ")
  ```

  ```python
  # 입력
  # 13
  # 1 2 1 3 2 4 3 5 3 6 4 7 5 8 5 9 6 10 6 11 7 12 11 13
  v = int(input())
  nodes = list(map(int, input().split()))
  tree = [[-1, -1] for _ in range(v+1)]

  for i in range(0, len(nodes), 2):
  	parent, child = nodes[i], nodes[i+1]

  	if tree[parent][0] == -1:
  		tree[parent][0] = child
  	else:
  		tree[parent][1] = child
  ```

---

## <mark color="#fbc956">완전 이진 트리</mark>

### 1. 완전 이진 트리

- 왼쪽부터 차례로 빈 곳 없이 채워진 이진트리
- **표현 방법**
  - 선형 자료구조 1개로 표현 가능
    | Index | 1 | 2 | 3 | 4 | 5 | 6 |
    | ----- | --- | --- | --- | --- | --- | --- |
    | - | 3 | 2 | 4 | 5 | 0 | 1 |
- **규칙성**
  - **부모 노드의 인덱스** : 자식의 인덱스를 2로 나눈 몫
  - **왼쪽 자식 인덱스** : 부모 노드 인덱스 \* 2
  - **오른쪽 자식 인덱스** : 부모 노드 인덱스 \* 2 + 1

### 2. 포화 이진 트리

- 모든 트리 레벨에서 노드가 꽉 차 있는 이진트리
  - 모든 층의 노드들이 빼곡히 차 있음
  - 노드의 레벨이 n일 경우, 총 개수는 (2^n-10)개
